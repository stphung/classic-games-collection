<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Breakout</title>
    <script src="transition-common.js"></script>
    <script src="submit-idea-button.js"></script>
    <script src="home-button.js"></script>
    <script src="mute-button.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e5e5e5;
            overflow: hidden;
            position: relative;
        }

        /* Subtle animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 30% 40%, rgba(255, 107, 107, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 70% 60%, rgba(78, 205, 196, 0.1) 0%, transparent 40%);
            z-index: -1;
        }

        .game-container {
            position: relative;
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        #canvas {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            background: #0f0f0f;
            display: block;
            will-change: transform;
            transform: translateZ(0);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .game-info {
            position: absolute;
            top: 40px;
            left: 40px;
            right: 40px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: 500;
            pointer-events: none;
            z-index: 10;
        }

        .score, .lives {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0.5px;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .game-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .overlay-title {
            font-size: 48px;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 4px;
            color: #ffffff;
        }

        .overlay-message {
            font-size: 18px;
            margin-bottom: 40px;
            color: #666;
            font-weight: 300;
        }

        .play-button {
            background: transparent;
            color: #e5e5e5;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 16px 48px;
            font-size: 16px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 300;
        }

        .play-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .instructions {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #444;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        .speed-selection {
            margin: 40px 0;
        }

        .speed-label {
            font-size: 16px;
            margin-bottom: 20px;
            color: #666;
            font-weight: 300;
        }

        .speed-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .speed-button {
            background: transparent;
            color: #999;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 24px;
            font-size: 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 300;
        }

        .speed-button:hover {
            color: #fff;
            border-color: rgba(255, 255, 255, 0.4);
        }

        .speed-button.selected {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }


        /* Custom cursor */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transition: all 0.1s ease;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="cursor"></div>
    <div class="game-container">
        <canvas id="canvas" width="800" height="600"></canvas>
        <div class="game-info">
            <div class="score">SCORE <span id="score">0</span></div>
            <div class="lives">LIVES <span id="lives">3</span></div>
        </div>
        <div class="game-overlay" id="startScreen">
            <h1 class="overlay-title">BREAKOUT</h1>
            <p class="overlay-message">Move your mouse to control the paddle</p>
            <div class="speed-selection">
                <p class="speed-label">SELECT DIFFICULTY</p>
                <div class="speed-buttons">
                    <button class="speed-button" onclick="setSpeed(0.8)">EASY</button>
                    <button class="speed-button" onclick="setSpeed(1.5)">NORMAL</button>
                    <button class="speed-button" onclick="setSpeed(2.5)">HARD</button>
                </div>
            </div>
            <button class="play-button" onclick="startGame()">START GAME</button>
        </div>
        <div class="game-overlay" id="gameOverScreen">
            <h1 class="overlay-title">GAME OVER</h1>
            <p class="overlay-message">FINAL SCORE <span id="finalScore">0</span></p>
            <button class="play-button" onclick="resetGame()">PLAY AGAIN</button>
        </div>
        <div class="instructions" id="instructions">MOVE MOUSE TO CONTROL</div>
    </div>
    

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Custom cursor
        const cursor = document.querySelector('.cursor');
        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });
        
        // Initialize Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let musicPlaying = false;
        let musicMuted = window.isGloballyMuted ? window.isGloballyMuted() : false;
        let musicInterval;
        let isMuted = window.isGloballyMuted ? window.isGloballyMuted() : false; // For sound effects

        // Sound effect functions
        function playSound(type) {
            if (isMuted) return; // Don't play sound effects if muted
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'paddleHit':
                    // Clean, high ping
                    const pingOsc = audioContext.createOscillator();
                    const pingGain = audioContext.createGain();
                    pingOsc.frequency.setValueAtTime(800, now);
                    pingOsc.type = 'sine';
                    pingGain.gain.setValueAtTime(0.08, now);
                    pingGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                    pingOsc.connect(pingGain);
                    pingGain.connect(audioContext.destination);
                    pingOsc.start(now);
                    pingOsc.stop(now + 0.03);
                    break;
                    
                case 'brickHit':
                    // Satisfying pop
                    const popOsc = audioContext.createOscillator();
                    const popGain = audioContext.createGain();
                    popOsc.frequency.setValueAtTime(600, now);
                    popOsc.frequency.exponentialRampToValueAtTime(300, now + 0.02);
                    popOsc.type = 'triangle';
                    popGain.gain.setValueAtTime(0.1, now);
                    popGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                    popOsc.connect(popGain);
                    popGain.connect(audioContext.destination);
                    popOsc.start(now);
                    popOsc.stop(now + 0.02);
                    break;
                    
                case 'lifeLost':
                    // Subtle descending tone
                    const lossOsc = audioContext.createOscillator();
                    const lossGain = audioContext.createGain();
                    lossOsc.frequency.setValueAtTime(300, now);
                    lossOsc.frequency.exponentialRampToValueAtTime(150, now + 0.3);
                    lossOsc.type = 'sine';
                    lossGain.gain.setValueAtTime(0.1, now);
                    lossGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    lossOsc.connect(lossGain);
                    lossGain.connect(audioContext.destination);
                    lossOsc.start(now);
                    lossOsc.stop(now + 0.3);
                    break;
                    
                case 'gameOver':
                    // Minimal game over sound
                    const notes = [300, 250, 200];
                    notes.forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.08, now + i * 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.2 + 0.3);
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.start(now + i * 0.2);
                        osc.stop(now + i * 0.2 + 0.3);
                    });
                    break;
            }
        }
        
        // Minimal ambient music
        function playBackgroundMusic() {
            if (!musicPlaying || audioContext.state === 'suspended' || musicMuted) return;
            
            const now = audioContext.currentTime;
            
            // Simple ambient pad
            const notes = [130.81, 164.81, 196.00, 164.81]; // C3, E3, G3, E3
            
            notes.forEach((freq, index) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                
                const startTime = now + index * 2;
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.02, startTime + 0.5);
                gain.gain.setValueAtTime(0.02, startTime + 1.5);
                gain.gain.linearRampToValueAtTime(0, startTime + 2);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(startTime);
                osc.stop(startTime + 2);
            });
        }
        
        function startMusic() {
            if (musicMuted) return;
            
            stopMusic();
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            musicPlaying = true;
            playBackgroundMusic();
            musicInterval = setInterval(playBackgroundMusic, 8000);
        }
        
        function stopMusic() {
            musicPlaying = false;
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
        }

        let ballSpeed = 300; // pixels per second
        let ball = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            dx: ballSpeed,
            dy: -ballSpeed,
            radius: 6,
            trail: [],
            speed: function() {
                return Math.sqrt(this.dx * this.dx + this.dy * this.dy);
            }
        };

        let paddle = {
            width: 100,
            height: 12,
            x: canvas.width / 2 - 50,
            y: canvas.height - 30
        };

        let bricks = [];
        const brickRowCount = 6;
        const brickColumnCount = 10;
        const brickWidth = 70;
        const brickHeight = 20;
        const brickPadding = 5;
        const brickOffsetTop = 80;
        const brickOffsetLeft = 35;

        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let ballLaunched = false;
        let particles = [];

        // Clean color palette
        const brickColors = [
            '#ff6b6b', // Red
            '#4ecdc4', // Teal
            '#45b7d1', // Blue
            '#96ceb4', // Mint
            '#feca57', // Yellow
            '#dfe6e9'  // Light gray
        ];

        function initBricks() {
            bricks = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[r] = [];
                for (let c = 0; c < brickColumnCount; c++) {
                    bricks[r][c] = { 
                        x: 0, 
                        y: 0, 
                        status: 1,
                        color: brickColors[r],
                        points: (brickRowCount - r) * 10
                    };
                }
            }
        }

        function drawBall() {
            // Subtle trail
            ball.trail.forEach((pos, index) => {
                const alpha = (index / ball.trail.length) * 0.2;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, ball.radius * (index / ball.trail.length), 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Clean white ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            // Simple rounded paddle
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, paddle.height / 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let r = 0; r < brickRowCount; r++) {
                for (let c = 0; c < brickColumnCount; c++) {
                    if (bricks[r][c].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[r][c].x = brickX;
                        bricks[r][c].y = brickY;

                        // Flat design with subtle depth
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, brickWidth, brickHeight, 3);
                        ctx.fillStyle = bricks[r][c].color;
                        ctx.fill();
                        ctx.closePath();
                        
                        // Very subtle highlight
                        ctx.beginPath();
                        ctx.roundRect(brickX, brickY, brickWidth, 1, 0);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * 120, // pixels per second
                    dy: Math.sin(angle) * 120, // pixels per second
                    size: 2,
                    color: color,
                    life: 1
                });
            }
        }

        function updateParticles(deltaTime) {
            particles = particles.filter(particle => {
                particle.x += particle.dx * deltaTime;
                particle.y += particle.dy * deltaTime;
                particle.dy += 300 * deltaTime; // gravity
                particle.life -= 2.4 * deltaTime;
                particle.dx *= Math.pow(0.95, deltaTime * 60);

                if (particle.life > 0) {
                    ctx.globalAlpha = particle.life * 0.5;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });
        }

        function collisionDetection(deltaTime) {
            // Store the ball's previous position
            const prevX = ball.x - ball.dx * deltaTime;
            const prevY = ball.y - ball.dy * deltaTime;
            
            for (let r = 0; r < brickRowCount; r++) {
                for (let c = 0; c < brickColumnCount; c++) {
                    const b = bricks[r][c];
                    if (b.status === 1) {
                        // Check if ball is colliding with brick
                        if (ball.x + ball.radius > b.x && 
                            ball.x - ball.radius < b.x + brickWidth && 
                            ball.y + ball.radius > b.y && 
                            ball.y - ball.radius < b.y + brickHeight) {
                            
                            // Determine which side of the brick was hit
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const brickCenterX = b.x + brickWidth / 2;
                            const brickCenterY = b.y + brickHeight / 2;
                            
                            // Calculate overlap on each axis
                            const overlapX = (brickWidth / 2 + ball.radius) - Math.abs(ballCenterX - brickCenterX);
                            const overlapY = (brickHeight / 2 + ball.radius) - Math.abs(ballCenterY - brickCenterY);
                            
                            // Determine collision side based on smallest overlap
                            if (overlapX < overlapY) {
                                // Hit from left or right
                                ball.dx = -ball.dx;
                                // Move ball out of brick
                                if (ballCenterX < brickCenterX) {
                                    ball.x = b.x - ball.radius;
                                } else {
                                    ball.x = b.x + brickWidth + ball.radius;
                                }
                            } else {
                                // Hit from top or bottom
                                ball.dy = -ball.dy;
                                // Move ball out of brick
                                if (ballCenterY < brickCenterY) {
                                    ball.y = b.y - ball.radius;
                                } else {
                                    ball.y = b.y + brickHeight + ball.radius;
                                }
                            }
                            
                            b.status = 0;
                            score += b.points;
                            updateScore();
                            createParticles(b.x + brickWidth / 2, b.y + brickHeight / 2, b.color);
                            playSound('brickHit');

                            if (score === getTotalPossibleScore()) {
                                gameWon();
                            }
                            
                            // Only handle one collision per frame
                            return;
                        }
                    }
                }
            }
        }

        function getTotalPossibleScore() {
            let total = 0;
            for (let r = 0; r < brickRowCount; r++) {
                total += (brickRowCount - r) * 10 * brickColumnCount;
            }
            return total;
        }

        function updateBall(deltaTime) {
            // If ball not launched, follow paddle
            if (!ballLaunched) {
                ball.x = paddle.x + paddle.width / 2;
                ball.y = paddle.y - ball.radius - 2;
                ball.trail = [];
                return;
            }
            
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 8) {
                ball.trail.shift();
            }

            // Store previous position for collision detection
            const prevX = ball.x;
            const prevY = ball.y;

            ball.x += ball.dx * deltaTime;
            ball.y += ball.dy * deltaTime;

            // Wall collisions
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.dx = -ball.dx;
            } else if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.dx = -ball.dx;
            }
            
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.dy = -ball.dy;
            }

            // Paddle collision
            if (ball.dy > 0 && // Ball moving downward
                ball.y + ball.radius > paddle.y && 
                ball.y - ball.radius < paddle.y + paddle.height &&
                ball.x > paddle.x && 
                ball.x < paddle.x + paddle.width &&
                prevY + ball.radius <= paddle.y) { // Was above paddle in previous frame
                
                // Calculate hit position for angle
                let hitPos = (ball.x - paddle.x) / paddle.width;
                hitPos = Math.max(0.1, Math.min(0.9, hitPos)); // Clamp to avoid extreme angles
                
                // Set new velocity based on hit position
                const maxAngle = Math.PI / 3; // 60 degrees max
                const angle = (hitPos - 0.5) * maxAngle;
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                
                ball.dx = speed * Math.sin(angle);
                ball.dy = -speed * Math.cos(angle);
                
                // Ensure ball doesn't get stuck
                ball.y = paddle.y - ball.radius;
                
                playSound('paddleHit');
            }

            // Ball fell off screen
            if (ball.y - ball.radius > canvas.height) {
                lives--;
                updateLives();
                if (lives === 0) {
                    gameOver();
                } else {
                    playSound('lifeLost');
                    resetBall();
                }
            }
        }

        function resetBall() {
            ballLaunched = false;
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.radius - 2;
            ball.dx = 0;
            ball.dy = 0;
            ball.trail = [];
            paddle.x = canvas.width / 2 - paddle.width / 2;
        }
        
        function launchBall() {
            if (!ballLaunched && gameRunning) {
                ballLaunched = true;
                // Random initial angle between -45 and 45 degrees
                const angle = (Math.random() - 0.5) * Math.PI / 2;
                ball.dx = ballSpeed * Math.sin(angle);
                ball.dy = -ballSpeed * Math.cos(angle);
            }
        }

        // Delta time tracking
        let lastTime = 0;
        
        function draw(currentTime) {
            // Calculate delta time in seconds
            const deltaTime = lastTime ? (currentTime - lastTime) / 1000 : 0;
            lastTime = currentTime;
            
            // Cap delta time to prevent large jumps
            const cappedDeltaTime = Math.min(deltaTime, 0.1);
            
            // Clean black background
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameRunning) {
                // Update physics first
                updateBall(cappedDeltaTime);
                if (ballLaunched) {
                    collisionDetection(cappedDeltaTime);
                }
                updateParticles(cappedDeltaTime);
                
                // Then draw everything
                drawBricks();
                drawBall();
                drawPaddle();
                
                // Show launch instruction
                if (!ballLaunched) {
                    ctx.font = '16px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.textAlign = 'center';
                    ctx.fillText('CLICK TO LAUNCH', canvas.width / 2, canvas.height / 2 + 100);
                }
            }

            requestAnimationFrame(draw);
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        function updateLives() {
            document.getElementById('lives').textContent = lives;
        }

        canvas.addEventListener('mousemove', (e) => {
            if (gameRunning) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddle.x = mouseX - paddle.width / 2;
                
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
        });
        
        canvas.addEventListener('click', (e) => {
            launchBall();
        });

        function setSpeed(speed) {
            ballSpeed = speed * 200; // Convert to pixels per second
            document.querySelectorAll('.speed-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function startGame() {
            document.getElementById('startScreen').classList.remove('active');
            gameRunning = true;
            ballLaunched = false;
            initBricks();
            resetBall();
            score = 0;
            lives = 3;
            updateScore();
            updateLives();
            startMusic();
        }

        function gameOver() {
            gameRunning = false;
            stopMusic();
            playSound('gameOver');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.add('active');
        }

        function gameWon() {
            gameRunning = false;
            stopMusic();
            document.getElementById('gameOverScreen').querySelector('.overlay-title').textContent = 'YOU WIN!';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.add('active');
        }

        function resetGame() {
            document.getElementById('gameOverScreen').classList.remove('active');
            document.getElementById('gameOverScreen').querySelector('.overlay-title').textContent = 'GAME OVER';
            startGame();
        }

        if (!ctx.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }

        // Keyboard event listener for ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                transitionToMenu();
                return;
            }
        });

        // Listen for global mute toggle
        window.addEventListener('globalMuteToggle', (event) => {
            isMuted = event.detail.isMuted;
            musicMuted = event.detail.isMuted;
            if (musicMuted) {
                stopMusic();
            } else if (gameRunning) {
                startMusic();
            }
        });

        document.getElementById('startScreen').classList.add('active');
        document.querySelectorAll('.speed-button')[1].classList.add('selected');
        draw();
    </script>
</body>
</html>